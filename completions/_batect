#compdef batect

typeset -a batect_completion_proxy_loaded_versions

_batect() {
    local wrapper_script_path
    wrapper_script_path="${words[1]}"

    if test ! -x "$wrapper_script_path"; then
        # If the wrapper script doesn't exist, fallback to as if this completion script doesn't exist.
        _files
        return
    fi

    local batect_version
    batect_version=$(sed -En 's/VERSION="(.*)"/\1/p' "$wrapper_script_path" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
    local use_disk_cache
    use_disk_cache=true

    if [[ "$batect_version" != "" ]]; then
        local batect_version_major batect_version_minor
        batect_version_major=$(echo "$batect_version" | sed -En 's/([0-9]+)\.([0-9]+)\..*/\1/p')
        batect_version_minor=$(echo "$batect_version" | sed -En 's/([0-9]+)\.([0-9]+)\..*/\2/p')

        if [[ "$batect_version_major" -eq 0 && "$batect_version_minor" -lt 67 ]]; then
            # If we know what the version is, and it's too old, fallback to as if this completion script doesn't exist.
            _files
            return
        fi
    else
        # HACK: this makes it easier to test completions locally when testing with the start script generated by Gradle.
        batect_version="0.0.0-local-dev"
        use_disk_cache=false
    fi

    export BATECT_COMPLETION_PROXY_REGISTER_AS="_batect-$batect_version"
    export BATECT_COMPLETION_PROXY_VERSION="0.2.0-dev"
    export BATECT_COMPLETION_PROXY_WRAPPER_PATH="$wrapper_script_path"

    # This syntax is explained at https://unix.stackexchange.com/a/411307/258093.
    if [[ ${batect_completion_proxy_loaded_versions[(ie)$batect_version]} -gt ${#batect_completion_proxy_loaded_versions} ]]; then
        _batect_load_completion_script "$wrapper_script_path" "$batect_version" "$use_disk_cache"
    fi

    local ret=1
    _call_function ret "$BATECT_COMPLETION_PROXY_REGISTER_AS" && return ret

    _message "Batect tab completion script for version $batect_version did not register expected function $BATECT_COMPLETION_PROXY_REGISTER_AS"
    return 1
}

_batect_load_completion_script() {
    local wrapper_script_path="$1"
    local batect_version="$2"
    local use_disk_cache="$3"
    local disk_cache_root="$HOME/.batect/completion/zsh-wrapper-$BATECT_COMPLETION_PROXY_VERSION"
    local disk_cache_path="$disk_cache_root/$batect_version"
    local completion_script

    if [[ "$use_disk_cache" == "true" && -f "$disk_cache_path" ]]; then
        completion_script=$(cat "$disk_cache_path")
    else
        completion_script=$(BATECT_QUIET_DOWNLOAD=true $wrapper_script_path --generate-completion-script=zsh) || (
            _message "Running Batect $batect_version to generate completion script failed: $completion_script" && return 1
        )
    fi

    eval "$completion_script"
    batect_completion_proxy_loaded_versions+=("$wrapper_script_path")

    if [[ "$use_disk_cache" == "true" && ! -f "$disk_cache_path" ]]; then
        mkdir -p "$disk_cache_root"
        echo "$completion_script" > "$disk_cache_path"
    fi
}

_batect "$@"
